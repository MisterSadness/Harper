// Reimplemented using ad-hoc types.
decimate :: Iterable a -> Integer -> Iterable a;
decimate xs n = {
  val ixs :: Iterable (a, Integer) = index xs;
  // Pattern matching of ad-hoc types.
  // The pipe operator is the equivalent of Haskell's ($)
  val s :: { item :: a, index :: Integer } -> a = \{ item: val x } => x;
  val f :: { item :: a, index :: Integer } -> Bool = \{ index: val i } => i mod n != 0;
  return map s | filter f ixs;

  // One can declare local functions in a block using `where`.
  where 
  index :: Iterable a -> Iterable { item :: a, index :: Integer };
  index xs = {
    var i :: Integer = 0;
    for val x :: a in xs {
    /* Creation of an ad-hoc type instance. */
      yield val { item :: a = x; index :: Integer = i; };
      i += 1;
    }
  };
};
