value List a = {
  variant Empty = {
    isEmpty :: Bool;
    isEmpty = true;

    // Implementing iterate is a special case as compared to normal functions.
    // If we're to treat List a as an Iterable a, all variants must declare
    // an iterate function.
    iterate :: Iterator a;
    iterate = { yield return; };
  };
  
  variant Nonempty = {
    data = {
      head :: a;
      tail :: List a;
    }
    
    isEmpty :: Bool;
    isEmpty = false;

    iterate :: Iterator a;
    iterate = {
      // The `this` identifier binds to the implicit first argument of a member function.
      var (current :: List a) = this;
      while not current.isEmpty {
        yield current.head;
        current := current.tail;
      }
    };
  };
};

// This can be generalised to Iterable a -> ().
printList :: List a -> sideeffect -> ();
printList xs = {
  for (x :: a) in xs {
    eval print x ();
  }
};

filter :: (a -> Bool) -> Iterable a -> Iterable a;
filter f xs = {
  for (x :: a) in xs {
    if f x {
	    yield x;
	  }
  }
};

map :: (a -> b) -> Iterable a -> Iterable b;
map f xs = {
  for (x :: a) in xs {
    yield f x;
  }
};

foldl :: (a -> b -> b) -> b -> Iterable a -> b;
foldl f acc xs = {
  var (result :: b) = acc;
  for (x :: a) in xs {
    result := f x result;
  }
  return result;
};
